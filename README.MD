# ioc [![Build Status](https://travis-ci.org/FilipMalczak/ioc.svg?branch=master)](https://travis-ci.org/FilipMalczak/ioc)
Slow approach to Ionversion of Control in D2 language

# Features

## Package scan

Add execution of generate_index.d with rdmd to your DUB file's 
preGenerateCommands to trigger building an index of modules. It works by adding
_index module to each package, that will contain struct with proper enumerations.
Values of those enums are submodules and subpackages, and that makes it possible
to traverse module tree both at compile- and runtime.

See unittest of ioc.codebase for example usage. That module is written based on
template folding (as in functional programming, sometimes called reduce). 

There is also lower-level API, exposed in _index module of each package. That 
module is generated by generate_index.d script and exposes struct Index, which
has 3 enum members: packageName having one value of string name of package in 
which it is located; submodules and subpackages, having one member per submodule 
or subpackage. Each member has package name with dots (.) replaced with underscores
(_) for member name and package name as string for member value. There of course
may be no members at all for either of those enums. package.d modules are not 
supported in indexing and won't be creating any members in submodules enum.

> There are two reasons not to support package modules.
>
> First is technical: allMembers traits is behaving in weird way when used on 
> a module or module alias that points to package module. I cannot exactly 
> understand why yet, but it looks like it even behaved differently on different
> platforms and may be a bug in the compiler - though it needs way more research
> and experiments before submitting such bug ticket. For now I think the time is
> better spent on developing simpler, but wider set of features, thus disabling
> support for package module, because...
>
> Second reason is more about idea behind the framework itself. My goal here is
> to create bare-metal architecture for pluggable framework, with low-level API
> and this essential "glue" to start developing environment of easily composable
> modules. It is highly convention-oriented, without many configuration 
> possibilities, though intention is to create API that allows for creating 
> higher abstractions, with more configuration options. Convention I would like
> to force here on API is that user should be working with top-level classes and
> interfaces, with fully qualified names that are distingishable and easily 
> broken down to tuples of package name, module name and simple name of a symbol.
> This rule is broken for package modules, which may be wonderful idea when 
> exposing an API, but rather poor when implementing something anyway. 
>
> Additionally, when looking at second reason from technical perspective, it is
> really helpful to assume that fullyQualifiedName!(symbol) can be splitted by a
> dot, last two elements taken as module and simple name of a symbol and rest 
> treated as package name. That assumption holds, because framework only 
> supports top-level classes and interfaces.
>
> For the record: there is support for manipulating (registering, weaving aspects,
> etc) only classes and interfaces, but there is also support for enums and structs
> besides them, when it comes to UDAs used as annotations.


I'd propose adding **/_index.d to .gitignore.

## Interceptors

### ioc.extendMethod

ioc.extendMethod defines Interceptor template interface and ExtendMethod template.

Interceptor is customized with interface from amongst which methods one will be intercepted,
name of that method and optional list of parameter types - needed only when there
is more than one overload for the method.

ExtendMethod template takes a concrete type and Interceptor implementation and
creates type that extends the concrete type but has a method intercepted.

See unittests for examples of usage and expected behaviour.

There is also InterceptorAdapter which provides empty interceptor for any
method - useful when we only want to intercept single crossing point.

### ioc.proxy

Provides simple delegating class with Proxy template. It does nothing, but
forward all the public API to wrapped instance.

### ioc.compose

Used to compose several interceptors with single template.


